1..32
# round one. four is_string results, gets the right count for characters and tokens.
ok 1 - result[0](ten) = output[0](ten)
ok 2 - result[1](chars) = output[1](chars)
ok 3 - result[2](!!) = output[2](!!)
ok 4 - result[3](3120) = output[3](3120)
ok 5 - should be 4 tokens.
ok 6 - Ten characters.
#  round two.  one big chunk, no delimiters. 24 chars, 1 token.
ok 7 - result[0](there can be only one.) = output[0](there can be only one.)
ok 8 - one token.
ok 9 - 22 characters, by strlen.
# round three.  one big chunk. 25 chars, 1 token.
ok 10 - result[0](one, but with boundaries.) = output[0](one, but with boundaries.)
ok 11 - one token.
ok 12 - 25 characters, by strlen.
# round four.  one big chunk. 25 chars, 1 token.
ok 13 - result[0](one, no start.) = output[0](one, no start.)
ok 14 - one token.
ok 15 - 14 characters, by strlen.
# Five, three tokens n stuff.
ok 16 - result[0](da) = output[0](da)
ok 17 - result[1](big) = output[1](big)
ok 18 - result[2](three) = output[2](three)
ok 19 - three tokens.
ok 20 - Ten characters.
# Six, one token at the front.
ok 21 - result[0](one, no end.) = output[0](one, no end.)
ok 22 - ONEEEE IS THE LONELEYESTTT
ok 23 - numba
# Seven, no tokens on ends.
ok 24 - result[0](seven) = output[0](seven)
ok 25 - result[1](seven) = output[1](seven)
ok 26 - result[2](seven) = output[2](seven)
ok 27 - three tokens.
ok 28 - fifteen characters.
# Eight, no tokens on ends, two delimiters.
ok 29 - result[0](ate) = output[0](ate)
ok 30 - result[1](nine) = output[1](nine)
ok 31 - two tokens.
ok 32 - seven characters.
# All 32 tests successful or skipped
